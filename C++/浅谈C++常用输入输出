# 浅谈C++常用输入输出

在编写C++程序的时候，经常因为输入输出头疼，所以在这里做一个小结，记录一下常用的输入输出，方便自己复习，也希望对和我有一样需求的人提供一些帮助。

> 目录：
1.  预备知识
2.  常用输入
**cin**    
**cin.get()**
**cin.getline()**
**getchar()**
**gets()**
**getline()**
3. 常用输出
**cout**
**cout.put()**
**putchar()**
**cerr**
**clog**

## 1.  预备知识

在C语言中，用printf和scanf进行输入输出，往往不能保证所输入输出的数据是可靠的安全的。在C++的输入输出中，编译系统对数据类型进行严格的检查，凡是类型不正确的数据都不可能通过编译。因此C++的I/O操作是类型安全(type safe)的。C++的I/O操作是可扩展的，不仅可以用来输入输出标准类型的数据，也可以用于用户自定义类型的数据。C++对标准类型的数据和对用户声明类型数据的输入输出，采用同样的方法处理。C++通过I/O类库来实现丰富的I/O功能。C++的输入输出优于C语言中的printf和scanf，但是比较复杂，要掌握许多细节。

输入和输出是数据传送的过程，数据如流水一样从一处流向另一处。C++形象地将此过程称为流(Stream)。C++的输入输出流是指由若干字节组成的宇节序列，这些宇节中的数据按顺序从一个对象传送到另一对象。流表示了信息从源到目的端的流动。在输入操作时，字节流从输入设备（如键盘、磁盘）流向内存，在输出操作时，字节流从内存流向输出设备(如屏幕、打印机、磁盘等)。流中的内容可以是ASCII字符、二进制形式的数据、图形图像、数字音频视频或其他形式的信息。

实际上，在内存中为每一个数据流开辟一个内存缓冲区，用来存放流中的数据。当用cout和插入运算符“<<”向显示器输出数据时，先将这些数据送到程序中的输出缓冲区保存，直到缓冲区满了或遇到endl，就将缓冲区中的全部数据送到显示器显示出来。在输入时，从键盘输入的数据先放在键盘的缓冲区中，当按回车键时，键盘缓冲区中的数据输入到程序中的输入缓冲区，形成cin流，然后用提取运算符“ >>”从输入缓冲区中提取数据送给程序中的有关变量。总之，流是与内存缓冲区相对应的，或者说，缓冲区中的数据就是流。

在C++中，输入输出流被定义为类。C++的I/O库中的类称为流类(stream class)。 用流类定义的对象称为流对象。

其实，cout和cin并不是C++语言中提供的语句，它们是iostream类的对象，在不了解类和对象时，在不致引起误解的前提下，为叙述方便，把它们称为cout语句和cin语句。正如C++并未提供赋值语句，只提供赋值表达式，在赋值表达式后面加分号就成了C++的语句，为方便起见，我们习惯称之为赋值语句。又如，在C语言中常用 printf和scanf进行输出和输入，printf和scanf是C语言库函数中的输入输出函数，一般也习惯地将由printf和scanf函数构成的语句称为printf语句和scanf语句。在使用它们时，对其本来的概念应该有准确的理解。

![I/O类库中的常用流类](http://upload-images.jianshu.io/upload_images/2996797-8818cef3259ccbb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 2.  常用输入
### cin
* cin是istream类的对象，它从标准输入设备(键盘)获取数据，程序中的变量通过流提取符“>>”从流中提取数据。流提取符“>>”从流中提取数据时通常跳过输入流中的空格、tab键、换行符等空白字符。
* 注意：只有在输入完数据再按回车键后，该行数据才被送入键盘缓冲区，形成输入流，提取运算符“>>”才能从中提取数据。需要注意保证从流中读取数据能正常进行。
* 当遇到无效字符或遇到文件结束符（不是换行符，是文件中的数据已读完）时，输入流cin就处于出错状态，即无法正常提取数据。此时对cin流的所有提取操作将终止。在 IBM PC及其兼容机中，以Ctrl + Z表示文件结束符。在UNIX和Macintosh系统中，以 Ctrl + D表示文件结束符。当输入流cin处于出错状态时，如果测试cin的值，可以发现它的值为false(假)，即cin为0值。如果输入流在正常状态，cin的值为true(真)，即cin为 一个非0值。可以通过测试cin的值，判断流对象是否处于正常状态和提取操作是否成功。如：
 ```
if(!cn)      //流cin处于出错状态，无法正常提取数据
        cout<<"error";
```
* 用法1：cin>>a>>b;   //最基本，也是最常用的用法，输入一个数字
  用法2：char a[20]; cin>>a;    // 接受一个字符串，遇“空格”、“TAB”、“回车”都结束

### cin.get()
* get()函数是cin输入流对象的成员函数，它有3种形式：无参数的，有一个参数的，有3个参数的。
* 不带参数的get函数，其调用形式为：
```
    cin.get();
```
用来从指定的输入流中提取一个字符（包括空白字符），函数的返回值就是读入的字符。 若遇到输入流中的文件结束符，则函数值返回文件结束标志EOF(End Of File)，一般以-1代表EOF，用-1而不用0或正值，是考虑到不与字符的ASCII代码混淆，但不同的C ++系统所用的EOF值有可能不同。
*  有一个参数的get函数，其调用形式为：
```
    cin.get(ch);
```
其作用是从输入流中读取一个字符，赋给字符变量ch。如果读取成功则函数返回true(真)，如失败(遇文件结束符) 则函数返回false(假)。
* 有3个参数的get函数，其调用形式为：
```
    cin.get(字符数组, 字符个数n, 终止字符);
```
或
```
    cin.get(字符指针, 字符个数n, 终止字符);
```
其作用是从输入流中读取n-1个字符，赋给指定的字符数组(或字符指针指向的数组)，如果在读取n-1个字符之前遇到指定的终止字符，则提前结束读取。如果读取成功则函数返回true(真)，如失败(遇文件结束符) 则函数返回false(假)。
**因为存放的是一个字符串，因此在n-1个字符之后要加入一个字符串结束标志，实际上存放到数组中的是n个字符。**
get函数中第3个参数可以省写，此时默认为'\n'。
* 用法1：cin.get(字符变量名);    //可以用来接收字符
  用法2：cin.get(字符数组名，接收字符数目);    //用来接收一行字符串,可以接收空格
  用法3：cin.get(无参数)没有参数主要是用于舍弃输入流中的不需要的字符,或者舍弃回车,弥补cin.get(字符数组名,接收字符数目)的不足。

### cin.getline()
* getline函数的作用是从输入流中读取一行字符,其用法与带3个参数的get函数类似。即：
```
    cin.getline(字符数组(或字符指针), 字符个数n, 终止标志字符);
```
* 用getline()函数从输入流读字符时，遇到终止标志字符时结束，指针移到该终止标志字符之后，下一个getline()函数将从该终止标志的下一个字符开始接着读入。如果用cin.get()函数从输入流读字符时，遇终止标志字符时停止读取，指针不向后移动，仍然停留在原位置。下一次读取时仍从该终止标志字符开始。这是getline()函数和get()函数不同之处。
* 用“cin<<”读数据时以空白字符(包括空格、tab键、回车键)作为终止标志，而用cin.getline()读数据时连续读取一系列字符，可以包括空格。用“cin <<”可以读取C++的标准类型的各类型数据（如果经过重载，还可以用于输入自定义类型的数据），而用cin.getline()只用于输入字符型数据。
* 用法：cin.getline()   // 接受一个字符串，可以接收空格并输出

### getchar()
* C语言中的getchar()函数与流成员函数cin.get( )的功能相同，C++保留了C的这种用法，可以用getchar(c)从键盘读入一个字符赋给c。

### gets()
* gets()是一个过时的函数，在C语言官方手册中，强烈建议用fgets()取代之！众所周知，gets()函数能从键盘接收空格，可以操作带有空格的字符串，但是因为C语言是将字符串当做一种数组操作的，既然是数组，就有长度，如果gets()函数读取的字符串长度大于被赋值数组的长度，就会引起溢出。建议使用c++中string类的getline()或其他读入方式！

### getline()
* 和cin.getline()类似，但是cin.getline()属于istream流，而getline()属于string流，是不一样的两个函数
* 用法：getline()     // 接受一个字符串，可以接收空格并输出，需包含“#include<string>”

## 3.  常用输出
### cout
* cout是console output的缩写，意为在控制台（终端显示器）的输出。
* cout不是C++预定义的关键字，它是ostream流类的对象，在iostream中定义。cout流中的数据是用流插入运算符“<<”顺序加入的。如：
```
cout<<"I "<<"study C++ "<<"very hard.";   
```
按顺序将字符串"I ", "study C++ ", "very hard."插人到cout流中，cout就将它们送到显示器，在显示器上输出字符串"I study C++ very hard."。cout流是容纳数据的载体，它并不是一个运算符。人们关心的是cout流中的内容，也就是向显示器输出什么。
* 用“cout<<”输出基本类型的数据时，可以不必考虑数据是什么类型，系统会判断数据的类型，并根据其类型选择调用与之匹配的运算符重载函数。这个过程都是自动的，用户不必干预。如果在C语言中用prinf函数输出不同类型的数据，必须分别指定相应的输出格式符，十分麻烦，而且容易出错。C++的I/O机制对用户来说，显然是方便而安全的。
* cout流在内存中对应开辟了一个缓冲区，用来存放流中的数据，当向cout流插 人一个endl时，不论缓冲区是否已满，都立即输出流中所有数据，然后插入一个换行符， 并刷新流（清空缓冲区）。注意如果插人一个换行符”\n“（如cout<<a<<"\n";），则只输出和换行，而不刷新cout流(但并不是所有编译系统都体现出这一区别）。
* 在iostream中只对"<<"和">>"运算符用于标准类型数据的输入输出进行了重载，但未对用户声明的类型数据的输入输出进行重载。如果用户声明了新的类型，并希望用"<<"和">>"运算符对其进行输入输出，应该对"<<"和">>"运算符另作重载。

### cout.put()
* 调用该函数的结果是在屏幕上显示一个字符。put函数的参数可以是字符或字符的ASCII代码(也可以是一个整型表达式)。
* 可以在一个语句中连续调用put函数。如：
 ```   
cout.put(71).put(79).put(79). put(68).put('\n');
```
在屏幕上显示GOOD。

### putchar()
* 除了使用cout.put函数输出一个字符外，还可以用putchar函数输出一个字符。putchar函数是C语言中使用的，在stdio.h头文件中定义。C++保留了这个函数，在iostream头文件中定义。

### cerr
* cerr流对象是标准错误流，cerr流已被指定为与显示器关联。cerr的作用是向标准错误设备(standard error device)输出有关出错信息。cerr与标准输出流cout的作用和用法差不多。但有一点不同：cout流通常是传送到显示器输出，但也可以被重定向输出到磁盘文件，而cerr流中的信息只能在显示器输出。当调试程序时，往往不希望程序运行时的出错信息被送到其他文件，而要求在显示器上及时输出，这时应该用cerr。cerr流中的信息是用户根据需要指定的。

### clog
* clog流对象也是标准错误流，它是console log的缩写。它的作用和cerr相同，都是在终端显示器上显示出错信息。区别：cerr是不经过缓冲区，直接向显示器上输出有关信息，而clog中的信息存放在缓冲区中，缓冲区满后或遇endl时向显示器输出。

## 特别注意：
* “<<”和“>>”本来在C++中是被定义为左位移运算符和右位移运算符的，由于在iostream头文件中对它们进行了重载，使它们能用作标准类型数据的输入和输出运算符。如果想将“<<”和“>>”用于自己声明的类型的数据，就不能简单地采用包含 iostream头文件来解决，必须自己对“<<”和“>>”进行重载。
* 不能用一个插入运算符“<<”插入多个输出项
* 不能用cin语句把空格字符和回车换行符作为字符输入给字符变量，它们将被跳过。如果想将空格字符或回车换行符(或任何其他键盘上的字符)输入给字符变量，可以使用getchar()函数。
* 如果在用cin.getline(ch, 20, '/')从输入流读取数据时，遇到回车键("\n")，是否结束读取？结论是此时"\n"不是结束标志"\n"被作为一个字符被读入。
* **ignore函数**，其调用形式为：
```   
 cin.ignore(n, 终止字符)
```
函数作用是跳过输入流中n个字符，或在遇到指定的终止字符时提前结束(此时跳过包括终止字符在内的若干字符)。如：
```
ighore(5, 'A')  //跳过输入流中5个字符，遇'A'后就不再跳了
```
也可以不带参数或只带一个参数。如：
```    
ignore( )  // n默认值为1，终止字符默认为EOF
```
相当于
```    
ignore(1, EOF)
```
* 注意:>> 是会过滤掉不可见字符（如 空格 回车，TAB 等） 
cin>>noskipws>>input[j];//不想略过空白字符，那就使用 noskipws 流控制

**参考资料：[C++输入输出详解](http://c.biancheng.net/cpp/biancheng/cpp/rumen_13/)**